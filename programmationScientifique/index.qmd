# Preface {.unnumbered}

Ce livre a pour but d'une part d'introduire les fondements de la programmation moderne, mais aussi de construire sur ces fondements pour faire en sorte que les lecteurs soient à l'aise à faire de la programmation scientifique. Le langage de choix de ce livre est Python, car il est parmi les langages les plus utilisés, surtout en sciences. Que ce soit les mathématiques, la physique, la biologie ou les sciences sociales, Python est un leader. Nous verrons bientôt pourquoi il en est ainsi. Mais avant, posons-nous la question suivante: pourquoi la programmation?

La réponse courte: parce que la complexité de la science augmente. En effet, le taille des données augmente, on veut aller dans le monde microscopique avec des lois de la nature de plus en plus capricieuses, on veut aller dans le très loin et gros avec des images à reconstruire. Sans les ordinateurs, la majorité de la science moderne serait pratiquement impossible. D'une part, l'utilisation des ordinateurs permet de stocker les données. D'autre part, on peut aisément manipuler ces données, en faire des copies et les analyser avec ces mêmes ordinateurs. On peut aussi penser à l'automatisation des tâches. Par exemple, si on fait un sondage auprès d'une population, on peut directement numériser les résultats et automatiquement à l'aide d'outils logiciels dérivés de divers champs de compétences scientifiques obtenir des conclusions à propos du sondage. On peut aussi penser à la récente image de trou noir qui a demandé des données d'une quantité inimaginable sans informatique et qui a aussi demandé une reconstruction qui serait impossible à faire à la main. Depuis plus de 50 ans, l'informatique et la programmation ont soulevé la science moderne et l'ont amené vers une progression excitante et jamais vue auparavant. Une tâche qui prenait des jours à faire il y a 100 ans peut maintenant demander quelques secondes ou moins! Je vous invite à inverser une matrice quelconque non triviale de taille $100\times 100$ à la main et de me donner le résultat en moins d'une heure. Ce ne sera fort probablement pas possible. Or, avec les ordinateurs modernes c'est tout à fait possible et ce très rapidement, pourvu que les algorithmes soient à la hauteur.

Concevoir de bons algorithmes n'est pas nécessairement facile. Selon la tâche, il faut avoir non seulement des bonnes connaissances en programmtion, mais aussi sur le sujet au coeur de l'algorithme. Si on reprend l'exemple de l'inversion de matrice, on doit non seulement être capable de manipuler des structures de données pour modéliser une matrice (ce qui est plutôt dans le secteur programmation), mais aussi connaître les méthodes les plus efficace pour inverser une matrice (ce qui relève plutôt de l'algèbre linéaire). Certains aspects d'un bon logiciel sont souvent plus abordés dans le monde du génie logiciel et je n'ai aucunement la prétention de me considérer ingénieur logiciel ou encore expert en développement de logiciel. C'est pourquoi ce livre ne sera pas vraiment un guide du parfait ingénieur logiciel, mais plutôt un guide sur comment faire ses propres outils Python pour la science et comment interpréter ou lire du code. Le développement de logiciels et leur partage ne sera pas vraiment discuté en détails, de même que les meilleures pratiques en programmation, d'autant plus que ces dernières sont étrangement arbitraires et subjectives, parfois sources de conflits entre programmeurs. Bref, on va se concenter sur la base premièrement, puis l'inclusion de modules et packages permettant de programmer nos analyses et algorithmes.